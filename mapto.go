// Code generated by maptoXXX.go DO NOT EDIT.

package fuego

// MapToBool produces an Stream[bool].
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
//
// This is method equivalent of the cast functions C/SC:
// C(s.StreamR, Bool) or SC(s.StreamR, Stream[bool])
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
func (s Stream[T]) MapToBool(toBool Function[T, bool]) Stream[bool] {
	outstream := make(chan bool, cap(s.stream))

	go func() {
		defer close(outstream)

		if s.stream == nil {
			return
		}
		
		for val := range s.stream {
			outstream <- toBool(val)
		}
	}()

	return NewConcurrentStream(outstream, s.concurrency)
}

// MapToSBool produces an Stream[[]bool].
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
//
// This is method equivalent of the cast functions C/SC:
// C(s.StreamR, SBool) or SC(s.StreamR, Stream[[]bool])
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
func (s Stream[T]) MapToSBool(toSBool Function[T, []bool]) Stream[[]bool] {
	outstream := make(chan []bool, cap(s.stream))

	go func() {
		defer close(outstream)

		if s.stream == nil {
			return
		}
		
		for val := range s.stream {
			outstream <- toSBool(val)
		}
	}()

	return NewConcurrentStream(outstream, s.concurrency)
}

// MapToBoolPtr produces an Stream[*bool].
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
//
// This is method equivalent of the cast functions C/SC:
// C(s.StreamR, BoolPtr) or SC(s.StreamR, Stream[*bool])
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
func (s Stream[T]) MapToBoolPtr(toBoolPtr Function[T, *bool]) Stream[*bool] {
	outstream := make(chan *bool, cap(s.stream))

	go func() {
		defer close(outstream)

		if s.stream == nil {
			return
		}
		
		for val := range s.stream {
			outstream <- toBoolPtr(val)
		}
	}()

	return NewConcurrentStream(outstream, s.concurrency)
}

// MapToSBoolPtr produces an Stream[[]*bool].
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
//
// This is method equivalent of the cast functions C/SC:
// C(s.StreamR, SBoolPtr) or SC(s.StreamR, Stream[[]*bool])
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
func (s Stream[T]) MapToSBoolPtr(toSBoolPtr Function[T, []*bool]) Stream[[]*bool] {
	outstream := make(chan []*bool, cap(s.stream))

	go func() {
		defer close(outstream)

		if s.stream == nil {
			return
		}
		
		for val := range s.stream {
			outstream <- toSBoolPtr(val)
		}
	}()

	return NewConcurrentStream(outstream, s.concurrency)
}

// MapToInt produces an Stream[int].
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
//
// This is method equivalent of the cast functions C/SC:
// C(s.StreamR, Int) or SC(s.StreamR, Stream[int])
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
func (s Stream[T]) MapToInt(toInt Function[T, int]) Stream[int] {
	outstream := make(chan int, cap(s.stream))

	go func() {
		defer close(outstream)

		if s.stream == nil {
			return
		}
		
		for val := range s.stream {
			outstream <- toInt(val)
		}
	}()

	return NewConcurrentStream(outstream, s.concurrency)
}

// MapToSInt produces an Stream[[]int].
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
//
// This is method equivalent of the cast functions C/SC:
// C(s.StreamR, SInt) or SC(s.StreamR, Stream[[]int])
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
func (s Stream[T]) MapToSInt(toSInt Function[T, []int]) Stream[[]int] {
	outstream := make(chan []int, cap(s.stream))

	go func() {
		defer close(outstream)

		if s.stream == nil {
			return
		}
		
		for val := range s.stream {
			outstream <- toSInt(val)
		}
	}()

	return NewConcurrentStream(outstream, s.concurrency)
}

// MapToIntPtr produces an Stream[*int].
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
//
// This is method equivalent of the cast functions C/SC:
// C(s.StreamR, IntPtr) or SC(s.StreamR, Stream[*int])
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
func (s Stream[T]) MapToIntPtr(toIntPtr Function[T, *int]) Stream[*int] {
	outstream := make(chan *int, cap(s.stream))

	go func() {
		defer close(outstream)

		if s.stream == nil {
			return
		}
		
		for val := range s.stream {
			outstream <- toIntPtr(val)
		}
	}()

	return NewConcurrentStream(outstream, s.concurrency)
}

// MapToSIntPtr produces an Stream[[]*int].
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
//
// This is method equivalent of the cast functions C/SC:
// C(s.StreamR, SIntPtr) or SC(s.StreamR, Stream[[]*int])
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
func (s Stream[T]) MapToSIntPtr(toSIntPtr Function[T, []*int]) Stream[[]*int] {
	outstream := make(chan []*int, cap(s.stream))

	go func() {
		defer close(outstream)

		if s.stream == nil {
			return
		}
		
		for val := range s.stream {
			outstream <- toSIntPtr(val)
		}
	}()

	return NewConcurrentStream(outstream, s.concurrency)
}

// MapToInt8 produces an Stream[int8].
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
//
// This is method equivalent of the cast functions C/SC:
// C(s.StreamR, Int8) or SC(s.StreamR, Stream[int8])
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
func (s Stream[T]) MapToInt8(toInt8 Function[T, int8]) Stream[int8] {
	outstream := make(chan int8, cap(s.stream))

	go func() {
		defer close(outstream)

		if s.stream == nil {
			return
		}
		
		for val := range s.stream {
			outstream <- toInt8(val)
		}
	}()

	return NewConcurrentStream(outstream, s.concurrency)
}

// MapToSInt8 produces an Stream[[]int8].
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
//
// This is method equivalent of the cast functions C/SC:
// C(s.StreamR, SInt8) or SC(s.StreamR, Stream[[]int8])
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
func (s Stream[T]) MapToSInt8(toSInt8 Function[T, []int8]) Stream[[]int8] {
	outstream := make(chan []int8, cap(s.stream))

	go func() {
		defer close(outstream)

		if s.stream == nil {
			return
		}
		
		for val := range s.stream {
			outstream <- toSInt8(val)
		}
	}()

	return NewConcurrentStream(outstream, s.concurrency)
}

// MapToInt8Ptr produces an Stream[*int8].
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
//
// This is method equivalent of the cast functions C/SC:
// C(s.StreamR, Int8Ptr) or SC(s.StreamR, Stream[*int8])
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
func (s Stream[T]) MapToInt8Ptr(toInt8Ptr Function[T, *int8]) Stream[*int8] {
	outstream := make(chan *int8, cap(s.stream))

	go func() {
		defer close(outstream)

		if s.stream == nil {
			return
		}
		
		for val := range s.stream {
			outstream <- toInt8Ptr(val)
		}
	}()

	return NewConcurrentStream(outstream, s.concurrency)
}

// MapToSInt8Ptr produces an Stream[[]*int8].
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
//
// This is method equivalent of the cast functions C/SC:
// C(s.StreamR, SInt8Ptr) or SC(s.StreamR, Stream[[]*int8])
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
func (s Stream[T]) MapToSInt8Ptr(toSInt8Ptr Function[T, []*int8]) Stream[[]*int8] {
	outstream := make(chan []*int8, cap(s.stream))

	go func() {
		defer close(outstream)

		if s.stream == nil {
			return
		}
		
		for val := range s.stream {
			outstream <- toSInt8Ptr(val)
		}
	}()

	return NewConcurrentStream(outstream, s.concurrency)
}

// MapToInt16 produces an Stream[int16].
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
//
// This is method equivalent of the cast functions C/SC:
// C(s.StreamR, Int16) or SC(s.StreamR, Stream[int16])
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
func (s Stream[T]) MapToInt16(toInt16 Function[T, int16]) Stream[int16] {
	outstream := make(chan int16, cap(s.stream))

	go func() {
		defer close(outstream)

		if s.stream == nil {
			return
		}
		
		for val := range s.stream {
			outstream <- toInt16(val)
		}
	}()

	return NewConcurrentStream(outstream, s.concurrency)
}

// MapToSInt16 produces an Stream[[]int16].
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
//
// This is method equivalent of the cast functions C/SC:
// C(s.StreamR, SInt16) or SC(s.StreamR, Stream[[]int16])
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
func (s Stream[T]) MapToSInt16(toSInt16 Function[T, []int16]) Stream[[]int16] {
	outstream := make(chan []int16, cap(s.stream))

	go func() {
		defer close(outstream)

		if s.stream == nil {
			return
		}
		
		for val := range s.stream {
			outstream <- toSInt16(val)
		}
	}()

	return NewConcurrentStream(outstream, s.concurrency)
}

// MapToInt16Ptr produces an Stream[*int16].
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
//
// This is method equivalent of the cast functions C/SC:
// C(s.StreamR, Int16Ptr) or SC(s.StreamR, Stream[*int16])
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
func (s Stream[T]) MapToInt16Ptr(toInt16Ptr Function[T, *int16]) Stream[*int16] {
	outstream := make(chan *int16, cap(s.stream))

	go func() {
		defer close(outstream)

		if s.stream == nil {
			return
		}
		
		for val := range s.stream {
			outstream <- toInt16Ptr(val)
		}
	}()

	return NewConcurrentStream(outstream, s.concurrency)
}

// MapToSInt16Ptr produces an Stream[[]*int16].
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
//
// This is method equivalent of the cast functions C/SC:
// C(s.StreamR, SInt16Ptr) or SC(s.StreamR, Stream[[]*int16])
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
func (s Stream[T]) MapToSInt16Ptr(toSInt16Ptr Function[T, []*int16]) Stream[[]*int16] {
	outstream := make(chan []*int16, cap(s.stream))

	go func() {
		defer close(outstream)

		if s.stream == nil {
			return
		}
		
		for val := range s.stream {
			outstream <- toSInt16Ptr(val)
		}
	}()

	return NewConcurrentStream(outstream, s.concurrency)
}

// MapToInt32 produces an Stream[int32].
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
//
// This is method equivalent of the cast functions C/SC:
// C(s.StreamR, Int32) or SC(s.StreamR, Stream[int32])
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
func (s Stream[T]) MapToInt32(toInt32 Function[T, int32]) Stream[int32] {
	outstream := make(chan int32, cap(s.stream))

	go func() {
		defer close(outstream)

		if s.stream == nil {
			return
		}
		
		for val := range s.stream {
			outstream <- toInt32(val)
		}
	}()

	return NewConcurrentStream(outstream, s.concurrency)
}

// MapToSInt32 produces an Stream[[]int32].
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
//
// This is method equivalent of the cast functions C/SC:
// C(s.StreamR, SInt32) or SC(s.StreamR, Stream[[]int32])
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
func (s Stream[T]) MapToSInt32(toSInt32 Function[T, []int32]) Stream[[]int32] {
	outstream := make(chan []int32, cap(s.stream))

	go func() {
		defer close(outstream)

		if s.stream == nil {
			return
		}
		
		for val := range s.stream {
			outstream <- toSInt32(val)
		}
	}()

	return NewConcurrentStream(outstream, s.concurrency)
}

// MapToInt32Ptr produces an Stream[*int32].
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
//
// This is method equivalent of the cast functions C/SC:
// C(s.StreamR, Int32Ptr) or SC(s.StreamR, Stream[*int32])
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
func (s Stream[T]) MapToInt32Ptr(toInt32Ptr Function[T, *int32]) Stream[*int32] {
	outstream := make(chan *int32, cap(s.stream))

	go func() {
		defer close(outstream)

		if s.stream == nil {
			return
		}
		
		for val := range s.stream {
			outstream <- toInt32Ptr(val)
		}
	}()

	return NewConcurrentStream(outstream, s.concurrency)
}

// MapToSInt32Ptr produces an Stream[[]*int32].
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
//
// This is method equivalent of the cast functions C/SC:
// C(s.StreamR, SInt32Ptr) or SC(s.StreamR, Stream[[]*int32])
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
func (s Stream[T]) MapToSInt32Ptr(toSInt32Ptr Function[T, []*int32]) Stream[[]*int32] {
	outstream := make(chan []*int32, cap(s.stream))

	go func() {
		defer close(outstream)

		if s.stream == nil {
			return
		}
		
		for val := range s.stream {
			outstream <- toSInt32Ptr(val)
		}
	}()

	return NewConcurrentStream(outstream, s.concurrency)
}

// MapToInt64 produces an Stream[int64].
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
//
// This is method equivalent of the cast functions C/SC:
// C(s.StreamR, Int64) or SC(s.StreamR, Stream[int64])
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
func (s Stream[T]) MapToInt64(toInt64 Function[T, int64]) Stream[int64] {
	outstream := make(chan int64, cap(s.stream))

	go func() {
		defer close(outstream)

		if s.stream == nil {
			return
		}
		
		for val := range s.stream {
			outstream <- toInt64(val)
		}
	}()

	return NewConcurrentStream(outstream, s.concurrency)
}

// MapToSInt64 produces an Stream[[]int64].
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
//
// This is method equivalent of the cast functions C/SC:
// C(s.StreamR, SInt64) or SC(s.StreamR, Stream[[]int64])
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
func (s Stream[T]) MapToSInt64(toSInt64 Function[T, []int64]) Stream[[]int64] {
	outstream := make(chan []int64, cap(s.stream))

	go func() {
		defer close(outstream)

		if s.stream == nil {
			return
		}
		
		for val := range s.stream {
			outstream <- toSInt64(val)
		}
	}()

	return NewConcurrentStream(outstream, s.concurrency)
}

// MapToInt64Ptr produces an Stream[*int64].
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
//
// This is method equivalent of the cast functions C/SC:
// C(s.StreamR, Int64Ptr) or SC(s.StreamR, Stream[*int64])
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
func (s Stream[T]) MapToInt64Ptr(toInt64Ptr Function[T, *int64]) Stream[*int64] {
	outstream := make(chan *int64, cap(s.stream))

	go func() {
		defer close(outstream)

		if s.stream == nil {
			return
		}
		
		for val := range s.stream {
			outstream <- toInt64Ptr(val)
		}
	}()

	return NewConcurrentStream(outstream, s.concurrency)
}

// MapToSInt64Ptr produces an Stream[[]*int64].
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
//
// This is method equivalent of the cast functions C/SC:
// C(s.StreamR, SInt64Ptr) or SC(s.StreamR, Stream[[]*int64])
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
func (s Stream[T]) MapToSInt64Ptr(toSInt64Ptr Function[T, []*int64]) Stream[[]*int64] {
	outstream := make(chan []*int64, cap(s.stream))

	go func() {
		defer close(outstream)

		if s.stream == nil {
			return
		}
		
		for val := range s.stream {
			outstream <- toSInt64Ptr(val)
		}
	}()

	return NewConcurrentStream(outstream, s.concurrency)
}

// MapToUint produces an Stream[uint].
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
//
// This is method equivalent of the cast functions C/SC:
// C(s.StreamR, Uint) or SC(s.StreamR, Stream[uint])
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
func (s Stream[T]) MapToUint(toUint Function[T, uint]) Stream[uint] {
	outstream := make(chan uint, cap(s.stream))

	go func() {
		defer close(outstream)

		if s.stream == nil {
			return
		}
		
		for val := range s.stream {
			outstream <- toUint(val)
		}
	}()

	return NewConcurrentStream(outstream, s.concurrency)
}

// MapToSUint produces an Stream[[]uint].
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
//
// This is method equivalent of the cast functions C/SC:
// C(s.StreamR, SUint) or SC(s.StreamR, Stream[[]uint])
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
func (s Stream[T]) MapToSUint(toSUint Function[T, []uint]) Stream[[]uint] {
	outstream := make(chan []uint, cap(s.stream))

	go func() {
		defer close(outstream)

		if s.stream == nil {
			return
		}
		
		for val := range s.stream {
			outstream <- toSUint(val)
		}
	}()

	return NewConcurrentStream(outstream, s.concurrency)
}

// MapToUintPtr produces an Stream[*uint].
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
//
// This is method equivalent of the cast functions C/SC:
// C(s.StreamR, UintPtr) or SC(s.StreamR, Stream[*uint])
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
func (s Stream[T]) MapToUintPtr(toUintPtr Function[T, *uint]) Stream[*uint] {
	outstream := make(chan *uint, cap(s.stream))

	go func() {
		defer close(outstream)

		if s.stream == nil {
			return
		}
		
		for val := range s.stream {
			outstream <- toUintPtr(val)
		}
	}()

	return NewConcurrentStream(outstream, s.concurrency)
}

// MapToSUintPtr produces an Stream[[]*uint].
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
//
// This is method equivalent of the cast functions C/SC:
// C(s.StreamR, SUintPtr) or SC(s.StreamR, Stream[[]*uint])
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
func (s Stream[T]) MapToSUintPtr(toSUintPtr Function[T, []*uint]) Stream[[]*uint] {
	outstream := make(chan []*uint, cap(s.stream))

	go func() {
		defer close(outstream)

		if s.stream == nil {
			return
		}
		
		for val := range s.stream {
			outstream <- toSUintPtr(val)
		}
	}()

	return NewConcurrentStream(outstream, s.concurrency)
}

// MapToUint8 produces an Stream[uint8].
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
//
// This is method equivalent of the cast functions C/SC:
// C(s.StreamR, Uint8) or SC(s.StreamR, Stream[uint8])
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
func (s Stream[T]) MapToUint8(toUint8 Function[T, uint8]) Stream[uint8] {
	outstream := make(chan uint8, cap(s.stream))

	go func() {
		defer close(outstream)

		if s.stream == nil {
			return
		}
		
		for val := range s.stream {
			outstream <- toUint8(val)
		}
	}()

	return NewConcurrentStream(outstream, s.concurrency)
}

// MapToSUint8 produces an Stream[[]uint8].
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
//
// This is method equivalent of the cast functions C/SC:
// C(s.StreamR, SUint8) or SC(s.StreamR, Stream[[]uint8])
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
func (s Stream[T]) MapToSUint8(toSUint8 Function[T, []uint8]) Stream[[]uint8] {
	outstream := make(chan []uint8, cap(s.stream))

	go func() {
		defer close(outstream)

		if s.stream == nil {
			return
		}
		
		for val := range s.stream {
			outstream <- toSUint8(val)
		}
	}()

	return NewConcurrentStream(outstream, s.concurrency)
}

// MapToUint8Ptr produces an Stream[*uint8].
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
//
// This is method equivalent of the cast functions C/SC:
// C(s.StreamR, Uint8Ptr) or SC(s.StreamR, Stream[*uint8])
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
func (s Stream[T]) MapToUint8Ptr(toUint8Ptr Function[T, *uint8]) Stream[*uint8] {
	outstream := make(chan *uint8, cap(s.stream))

	go func() {
		defer close(outstream)

		if s.stream == nil {
			return
		}
		
		for val := range s.stream {
			outstream <- toUint8Ptr(val)
		}
	}()

	return NewConcurrentStream(outstream, s.concurrency)
}

// MapToSUint8Ptr produces an Stream[[]*uint8].
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
//
// This is method equivalent of the cast functions C/SC:
// C(s.StreamR, SUint8Ptr) or SC(s.StreamR, Stream[[]*uint8])
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
func (s Stream[T]) MapToSUint8Ptr(toSUint8Ptr Function[T, []*uint8]) Stream[[]*uint8] {
	outstream := make(chan []*uint8, cap(s.stream))

	go func() {
		defer close(outstream)

		if s.stream == nil {
			return
		}
		
		for val := range s.stream {
			outstream <- toSUint8Ptr(val)
		}
	}()

	return NewConcurrentStream(outstream, s.concurrency)
}

// MapToUint16 produces an Stream[uint16].
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
//
// This is method equivalent of the cast functions C/SC:
// C(s.StreamR, Uint16) or SC(s.StreamR, Stream[uint16])
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
func (s Stream[T]) MapToUint16(toUint16 Function[T, uint16]) Stream[uint16] {
	outstream := make(chan uint16, cap(s.stream))

	go func() {
		defer close(outstream)

		if s.stream == nil {
			return
		}
		
		for val := range s.stream {
			outstream <- toUint16(val)
		}
	}()

	return NewConcurrentStream(outstream, s.concurrency)
}

// MapToSUint16 produces an Stream[[]uint16].
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
//
// This is method equivalent of the cast functions C/SC:
// C(s.StreamR, SUint16) or SC(s.StreamR, Stream[[]uint16])
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
func (s Stream[T]) MapToSUint16(toSUint16 Function[T, []uint16]) Stream[[]uint16] {
	outstream := make(chan []uint16, cap(s.stream))

	go func() {
		defer close(outstream)

		if s.stream == nil {
			return
		}
		
		for val := range s.stream {
			outstream <- toSUint16(val)
		}
	}()

	return NewConcurrentStream(outstream, s.concurrency)
}

// MapToUint16Ptr produces an Stream[*uint16].
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
//
// This is method equivalent of the cast functions C/SC:
// C(s.StreamR, Uint16Ptr) or SC(s.StreamR, Stream[*uint16])
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
func (s Stream[T]) MapToUint16Ptr(toUint16Ptr Function[T, *uint16]) Stream[*uint16] {
	outstream := make(chan *uint16, cap(s.stream))

	go func() {
		defer close(outstream)

		if s.stream == nil {
			return
		}
		
		for val := range s.stream {
			outstream <- toUint16Ptr(val)
		}
	}()

	return NewConcurrentStream(outstream, s.concurrency)
}

// MapToSUint16Ptr produces an Stream[[]*uint16].
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
//
// This is method equivalent of the cast functions C/SC:
// C(s.StreamR, SUint16Ptr) or SC(s.StreamR, Stream[[]*uint16])
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
func (s Stream[T]) MapToSUint16Ptr(toSUint16Ptr Function[T, []*uint16]) Stream[[]*uint16] {
	outstream := make(chan []*uint16, cap(s.stream))

	go func() {
		defer close(outstream)

		if s.stream == nil {
			return
		}
		
		for val := range s.stream {
			outstream <- toSUint16Ptr(val)
		}
	}()

	return NewConcurrentStream(outstream, s.concurrency)
}

// MapToUint32 produces an Stream[uint32].
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
//
// This is method equivalent of the cast functions C/SC:
// C(s.StreamR, Uint32) or SC(s.StreamR, Stream[uint32])
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
func (s Stream[T]) MapToUint32(toUint32 Function[T, uint32]) Stream[uint32] {
	outstream := make(chan uint32, cap(s.stream))

	go func() {
		defer close(outstream)

		if s.stream == nil {
			return
		}
		
		for val := range s.stream {
			outstream <- toUint32(val)
		}
	}()

	return NewConcurrentStream(outstream, s.concurrency)
}

// MapToSUint32 produces an Stream[[]uint32].
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
//
// This is method equivalent of the cast functions C/SC:
// C(s.StreamR, SUint32) or SC(s.StreamR, Stream[[]uint32])
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
func (s Stream[T]) MapToSUint32(toSUint32 Function[T, []uint32]) Stream[[]uint32] {
	outstream := make(chan []uint32, cap(s.stream))

	go func() {
		defer close(outstream)

		if s.stream == nil {
			return
		}
		
		for val := range s.stream {
			outstream <- toSUint32(val)
		}
	}()

	return NewConcurrentStream(outstream, s.concurrency)
}

// MapToUint32Ptr produces an Stream[*uint32].
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
//
// This is method equivalent of the cast functions C/SC:
// C(s.StreamR, Uint32Ptr) or SC(s.StreamR, Stream[*uint32])
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
func (s Stream[T]) MapToUint32Ptr(toUint32Ptr Function[T, *uint32]) Stream[*uint32] {
	outstream := make(chan *uint32, cap(s.stream))

	go func() {
		defer close(outstream)

		if s.stream == nil {
			return
		}
		
		for val := range s.stream {
			outstream <- toUint32Ptr(val)
		}
	}()

	return NewConcurrentStream(outstream, s.concurrency)
}

// MapToSUint32Ptr produces an Stream[[]*uint32].
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
//
// This is method equivalent of the cast functions C/SC:
// C(s.StreamR, SUint32Ptr) or SC(s.StreamR, Stream[[]*uint32])
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
func (s Stream[T]) MapToSUint32Ptr(toSUint32Ptr Function[T, []*uint32]) Stream[[]*uint32] {
	outstream := make(chan []*uint32, cap(s.stream))

	go func() {
		defer close(outstream)

		if s.stream == nil {
			return
		}
		
		for val := range s.stream {
			outstream <- toSUint32Ptr(val)
		}
	}()

	return NewConcurrentStream(outstream, s.concurrency)
}

// MapToUint64 produces an Stream[uint64].
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
//
// This is method equivalent of the cast functions C/SC:
// C(s.StreamR, Uint64) or SC(s.StreamR, Stream[uint64])
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
func (s Stream[T]) MapToUint64(toUint64 Function[T, uint64]) Stream[uint64] {
	outstream := make(chan uint64, cap(s.stream))

	go func() {
		defer close(outstream)

		if s.stream == nil {
			return
		}
		
		for val := range s.stream {
			outstream <- toUint64(val)
		}
	}()

	return NewConcurrentStream(outstream, s.concurrency)
}

// MapToSUint64 produces an Stream[[]uint64].
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
//
// This is method equivalent of the cast functions C/SC:
// C(s.StreamR, SUint64) or SC(s.StreamR, Stream[[]uint64])
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
func (s Stream[T]) MapToSUint64(toSUint64 Function[T, []uint64]) Stream[[]uint64] {
	outstream := make(chan []uint64, cap(s.stream))

	go func() {
		defer close(outstream)

		if s.stream == nil {
			return
		}
		
		for val := range s.stream {
			outstream <- toSUint64(val)
		}
	}()

	return NewConcurrentStream(outstream, s.concurrency)
}

// MapToUint64Ptr produces an Stream[*uint64].
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
//
// This is method equivalent of the cast functions C/SC:
// C(s.StreamR, Uint64Ptr) or SC(s.StreamR, Stream[*uint64])
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
func (s Stream[T]) MapToUint64Ptr(toUint64Ptr Function[T, *uint64]) Stream[*uint64] {
	outstream := make(chan *uint64, cap(s.stream))

	go func() {
		defer close(outstream)

		if s.stream == nil {
			return
		}
		
		for val := range s.stream {
			outstream <- toUint64Ptr(val)
		}
	}()

	return NewConcurrentStream(outstream, s.concurrency)
}

// MapToSUint64Ptr produces an Stream[[]*uint64].
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
//
// This is method equivalent of the cast functions C/SC:
// C(s.StreamR, SUint64Ptr) or SC(s.StreamR, Stream[[]*uint64])
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
func (s Stream[T]) MapToSUint64Ptr(toSUint64Ptr Function[T, []*uint64]) Stream[[]*uint64] {
	outstream := make(chan []*uint64, cap(s.stream))

	go func() {
		defer close(outstream)

		if s.stream == nil {
			return
		}
		
		for val := range s.stream {
			outstream <- toSUint64Ptr(val)
		}
	}()

	return NewConcurrentStream(outstream, s.concurrency)
}

// MapToFloat32 produces an Stream[float32].
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
//
// This is method equivalent of the cast functions C/SC:
// C(s.StreamR, Float32) or SC(s.StreamR, Stream[float32])
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
func (s Stream[T]) MapToFloat32(toFloat32 Function[T, float32]) Stream[float32] {
	outstream := make(chan float32, cap(s.stream))

	go func() {
		defer close(outstream)

		if s.stream == nil {
			return
		}
		
		for val := range s.stream {
			outstream <- toFloat32(val)
		}
	}()

	return NewConcurrentStream(outstream, s.concurrency)
}

// MapToSFloat32 produces an Stream[[]float32].
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
//
// This is method equivalent of the cast functions C/SC:
// C(s.StreamR, SFloat32) or SC(s.StreamR, Stream[[]float32])
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
func (s Stream[T]) MapToSFloat32(toSFloat32 Function[T, []float32]) Stream[[]float32] {
	outstream := make(chan []float32, cap(s.stream))

	go func() {
		defer close(outstream)

		if s.stream == nil {
			return
		}
		
		for val := range s.stream {
			outstream <- toSFloat32(val)
		}
	}()

	return NewConcurrentStream(outstream, s.concurrency)
}

// MapToFloat32Ptr produces an Stream[*float32].
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
//
// This is method equivalent of the cast functions C/SC:
// C(s.StreamR, Float32Ptr) or SC(s.StreamR, Stream[*float32])
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
func (s Stream[T]) MapToFloat32Ptr(toFloat32Ptr Function[T, *float32]) Stream[*float32] {
	outstream := make(chan *float32, cap(s.stream))

	go func() {
		defer close(outstream)

		if s.stream == nil {
			return
		}
		
		for val := range s.stream {
			outstream <- toFloat32Ptr(val)
		}
	}()

	return NewConcurrentStream(outstream, s.concurrency)
}

// MapToSFloat32Ptr produces an Stream[[]*float32].
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
//
// This is method equivalent of the cast functions C/SC:
// C(s.StreamR, SFloat32Ptr) or SC(s.StreamR, Stream[[]*float32])
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
func (s Stream[T]) MapToSFloat32Ptr(toSFloat32Ptr Function[T, []*float32]) Stream[[]*float32] {
	outstream := make(chan []*float32, cap(s.stream))

	go func() {
		defer close(outstream)

		if s.stream == nil {
			return
		}
		
		for val := range s.stream {
			outstream <- toSFloat32Ptr(val)
		}
	}()

	return NewConcurrentStream(outstream, s.concurrency)
}

// MapToFloat64 produces an Stream[float64].
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
//
// This is method equivalent of the cast functions C/SC:
// C(s.StreamR, Float64) or SC(s.StreamR, Stream[float64])
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
func (s Stream[T]) MapToFloat64(toFloat64 Function[T, float64]) Stream[float64] {
	outstream := make(chan float64, cap(s.stream))

	go func() {
		defer close(outstream)

		if s.stream == nil {
			return
		}
		
		for val := range s.stream {
			outstream <- toFloat64(val)
		}
	}()

	return NewConcurrentStream(outstream, s.concurrency)
}

// MapToSFloat64 produces an Stream[[]float64].
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
//
// This is method equivalent of the cast functions C/SC:
// C(s.StreamR, SFloat64) or SC(s.StreamR, Stream[[]float64])
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
func (s Stream[T]) MapToSFloat64(toSFloat64 Function[T, []float64]) Stream[[]float64] {
	outstream := make(chan []float64, cap(s.stream))

	go func() {
		defer close(outstream)

		if s.stream == nil {
			return
		}
		
		for val := range s.stream {
			outstream <- toSFloat64(val)
		}
	}()

	return NewConcurrentStream(outstream, s.concurrency)
}

// MapToFloat64Ptr produces an Stream[*float64].
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
//
// This is method equivalent of the cast functions C/SC:
// C(s.StreamR, Float64Ptr) or SC(s.StreamR, Stream[*float64])
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
func (s Stream[T]) MapToFloat64Ptr(toFloat64Ptr Function[T, *float64]) Stream[*float64] {
	outstream := make(chan *float64, cap(s.stream))

	go func() {
		defer close(outstream)

		if s.stream == nil {
			return
		}
		
		for val := range s.stream {
			outstream <- toFloat64Ptr(val)
		}
	}()

	return NewConcurrentStream(outstream, s.concurrency)
}

// MapToSFloat64Ptr produces an Stream[[]*float64].
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
//
// This is method equivalent of the cast functions C/SC:
// C(s.StreamR, SFloat64Ptr) or SC(s.StreamR, Stream[[]*float64])
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
func (s Stream[T]) MapToSFloat64Ptr(toSFloat64Ptr Function[T, []*float64]) Stream[[]*float64] {
	outstream := make(chan []*float64, cap(s.stream))

	go func() {
		defer close(outstream)

		if s.stream == nil {
			return
		}
		
		for val := range s.stream {
			outstream <- toSFloat64Ptr(val)
		}
	}()

	return NewConcurrentStream(outstream, s.concurrency)
}

// MapToComplex64 produces an Stream[complex128].
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
//
// This is method equivalent of the cast functions C/SC:
// C(s.StreamR, Complex64) or SC(s.StreamR, Stream[complex128])
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
func (s Stream[T]) MapToComplex64(toComplex64 Function[T, complex128]) Stream[complex128] {
	outstream := make(chan complex128, cap(s.stream))

	go func() {
		defer close(outstream)

		if s.stream == nil {
			return
		}
		
		for val := range s.stream {
			outstream <- toComplex64(val)
		}
	}()

	return NewConcurrentStream(outstream, s.concurrency)
}

// MapToSComplex64 produces an Stream[[]complex128].
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
//
// This is method equivalent of the cast functions C/SC:
// C(s.StreamR, SComplex64) or SC(s.StreamR, Stream[[]complex128])
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
func (s Stream[T]) MapToSComplex64(toSComplex64 Function[T, []complex128]) Stream[[]complex128] {
	outstream := make(chan []complex128, cap(s.stream))

	go func() {
		defer close(outstream)

		if s.stream == nil {
			return
		}
		
		for val := range s.stream {
			outstream <- toSComplex64(val)
		}
	}()

	return NewConcurrentStream(outstream, s.concurrency)
}

// MapToComplex64Ptr produces an Stream[*complex128].
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
//
// This is method equivalent of the cast functions C/SC:
// C(s.StreamR, Complex64Ptr) or SC(s.StreamR, Stream[*complex128])
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
func (s Stream[T]) MapToComplex64Ptr(toComplex64Ptr Function[T, *complex128]) Stream[*complex128] {
	outstream := make(chan *complex128, cap(s.stream))

	go func() {
		defer close(outstream)

		if s.stream == nil {
			return
		}
		
		for val := range s.stream {
			outstream <- toComplex64Ptr(val)
		}
	}()

	return NewConcurrentStream(outstream, s.concurrency)
}

// MapToSComplex64Ptr produces an Stream[[]*complex128].
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
//
// This is method equivalent of the cast functions C/SC:
// C(s.StreamR, SComplex64Ptr) or SC(s.StreamR, Stream[[]*complex128])
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
func (s Stream[T]) MapToSComplex64Ptr(toSComplex64Ptr Function[T, []*complex128]) Stream[[]*complex128] {
	outstream := make(chan []*complex128, cap(s.stream))

	go func() {
		defer close(outstream)

		if s.stream == nil {
			return
		}
		
		for val := range s.stream {
			outstream <- toSComplex64Ptr(val)
		}
	}()

	return NewConcurrentStream(outstream, s.concurrency)
}

// MapToComplex128 produces an Stream[complex128].
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
//
// This is method equivalent of the cast functions C/SC:
// C(s.StreamR, Complex128) or SC(s.StreamR, Stream[complex128])
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
func (s Stream[T]) MapToComplex128(toComplex128 Function[T, complex128]) Stream[complex128] {
	outstream := make(chan complex128, cap(s.stream))

	go func() {
		defer close(outstream)

		if s.stream == nil {
			return
		}
		
		for val := range s.stream {
			outstream <- toComplex128(val)
		}
	}()

	return NewConcurrentStream(outstream, s.concurrency)
}

// MapToSComplex128 produces an Stream[[]complex128].
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
//
// This is method equivalent of the cast functions C/SC:
// C(s.StreamR, SComplex128) or SC(s.StreamR, Stream[[]complex128])
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
func (s Stream[T]) MapToSComplex128(toSComplex128 Function[T, []complex128]) Stream[[]complex128] {
	outstream := make(chan []complex128, cap(s.stream))

	go func() {
		defer close(outstream)

		if s.stream == nil {
			return
		}
		
		for val := range s.stream {
			outstream <- toSComplex128(val)
		}
	}()

	return NewConcurrentStream(outstream, s.concurrency)
}

// MapToComplex128Ptr produces an Stream[*complex128].
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
//
// This is method equivalent of the cast functions C/SC:
// C(s.StreamR, Complex128Ptr) or SC(s.StreamR, Stream[*complex128])
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
func (s Stream[T]) MapToComplex128Ptr(toComplex128Ptr Function[T, *complex128]) Stream[*complex128] {
	outstream := make(chan *complex128, cap(s.stream))

	go func() {
		defer close(outstream)

		if s.stream == nil {
			return
		}
		
		for val := range s.stream {
			outstream <- toComplex128Ptr(val)
		}
	}()

	return NewConcurrentStream(outstream, s.concurrency)
}

// MapToSComplex128Ptr produces an Stream[[]*complex128].
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
//
// This is method equivalent of the cast functions C/SC:
// C(s.StreamR, SComplex128Ptr) or SC(s.StreamR, Stream[[]*complex128])
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
func (s Stream[T]) MapToSComplex128Ptr(toSComplex128Ptr Function[T, []*complex128]) Stream[[]*complex128] {
	outstream := make(chan []*complex128, cap(s.stream))

	go func() {
		defer close(outstream)

		if s.stream == nil {
			return
		}
		
		for val := range s.stream {
			outstream <- toSComplex128Ptr(val)
		}
	}()

	return NewConcurrentStream(outstream, s.concurrency)
}

// MapToString produces an Stream[string].
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
//
// This is method equivalent of the cast functions C/SC:
// C(s.StreamR, String) or SC(s.StreamR, Stream[string])
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
func (s Stream[T]) MapToString(toString Function[T, string]) Stream[string] {
	outstream := make(chan string, cap(s.stream))

	go func() {
		defer close(outstream)

		if s.stream == nil {
			return
		}
		
		for val := range s.stream {
			outstream <- toString(val)
		}
	}()

	return NewConcurrentStream(outstream, s.concurrency)
}

// MapToSString produces an Stream[[]string].
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
//
// This is method equivalent of the cast functions C/SC:
// C(s.StreamR, SString) or SC(s.StreamR, Stream[[]string])
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
func (s Stream[T]) MapToSString(toSString Function[T, []string]) Stream[[]string] {
	outstream := make(chan []string, cap(s.stream))

	go func() {
		defer close(outstream)

		if s.stream == nil {
			return
		}
		
		for val := range s.stream {
			outstream <- toSString(val)
		}
	}()

	return NewConcurrentStream(outstream, s.concurrency)
}

// MapToStringPtr produces an Stream[*string].
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
//
// This is method equivalent of the cast functions C/SC:
// C(s.StreamR, StringPtr) or SC(s.StreamR, Stream[*string])
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
func (s Stream[T]) MapToStringPtr(toStringPtr Function[T, *string]) Stream[*string] {
	outstream := make(chan *string, cap(s.stream))

	go func() {
		defer close(outstream)

		if s.stream == nil {
			return
		}
		
		for val := range s.stream {
			outstream <- toStringPtr(val)
		}
	}()

	return NewConcurrentStream(outstream, s.concurrency)
}

// MapToSStringPtr produces an Stream[[]*string].
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
//
// This is method equivalent of the cast functions C/SC:
// C(s.StreamR, SStringPtr) or SC(s.StreamR, Stream[[]*string])
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
func (s Stream[T]) MapToSStringPtr(toSStringPtr Function[T, []*string]) Stream[[]*string] {
	outstream := make(chan []*string, cap(s.stream))

	go func() {
		defer close(outstream)

		if s.stream == nil {
			return
		}
		
		for val := range s.stream {
			outstream <- toSStringPtr(val)
		}
	}()

	return NewConcurrentStream(outstream, s.concurrency)
}


// Code generated by maptoXXX.go DO NOT EDIT.

package fuego

// MapToBool produces a new Stream[bool] applying the
//provided Function[T, bool] to the elements of the stream.
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
//
// It is a special case of Map() aiming to avoid the use of functions C or SC for native Go types.
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
func (s Stream[T]) MapToBool(mapper Function[T, bool]) Stream[bool] {
	return NewConcurrentStream(orderlyConcurrentDo(s, mapper), s.concurrency)
}

// FlatMapToBool produces a new Stream[bool] applying the
// provided StreamFunction[T, bool] to flatten the elements of the stream.
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
//
// It is a special case of FlatMap() aiming to avoid the use of functions C or SC for native Go types.
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
func (s Stream[T]) FlatMapToBool(mapper StreamFunction[T, bool]) Stream[bool] {
	return NewConcurrentStream(orderlyConcurrentDoStream(s, mapper), s.concurrency)
}

// MapToSBool produces a new Stream[[]bool] applying the
//provided Function[T, []bool] to the elements of the stream.
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
//
// It is a special case of Map() aiming to avoid the use of functions C or SC for native Go types.
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
func (s Stream[T]) MapToSBool(mapper Function[T, []bool]) Stream[[]bool] {
	return NewConcurrentStream(orderlyConcurrentDo(s, mapper), s.concurrency)
}

// FlatMapToSBool produces a new Stream[[]bool] applying the
// provided StreamFunction[T, []bool] to flatten the elements of the stream.
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
//
// It is a special case of FlatMap() aiming to avoid the use of functions C or SC for native Go types.
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
func (s Stream[T]) FlatMapToSBool(mapper StreamFunction[T, []bool]) Stream[[]bool] {
	return NewConcurrentStream(orderlyConcurrentDoStream(s, mapper), s.concurrency)
}

// MapToBoolPtr produces a new Stream[*bool] applying the
//provided Function[T, *bool] to the elements of the stream.
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
//
// It is a special case of Map() aiming to avoid the use of functions C or SC for native Go types.
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
func (s Stream[T]) MapToBoolPtr(mapper Function[T, *bool]) Stream[*bool] {
	return NewConcurrentStream(orderlyConcurrentDo(s, mapper), s.concurrency)
}

// FlatMapToBoolPtr produces a new Stream[*bool] applying the
// provided StreamFunction[T, *bool] to flatten the elements of the stream.
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
//
// It is a special case of FlatMap() aiming to avoid the use of functions C or SC for native Go types.
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
func (s Stream[T]) FlatMapToBoolPtr(mapper StreamFunction[T, *bool]) Stream[*bool] {
	return NewConcurrentStream(orderlyConcurrentDoStream(s, mapper), s.concurrency)
}

// MapToSBoolPtr produces a new Stream[[]*bool] applying the
//provided Function[T, []*bool] to the elements of the stream.
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
//
// It is a special case of Map() aiming to avoid the use of functions C or SC for native Go types.
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
func (s Stream[T]) MapToSBoolPtr(mapper Function[T, []*bool]) Stream[[]*bool] {
	return NewConcurrentStream(orderlyConcurrentDo(s, mapper), s.concurrency)
}

// FlatMapToSBoolPtr produces a new Stream[[]*bool] applying the
// provided StreamFunction[T, []*bool] to flatten the elements of the stream.
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
//
// It is a special case of FlatMap() aiming to avoid the use of functions C or SC for native Go types.
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
func (s Stream[T]) FlatMapToSBoolPtr(mapper StreamFunction[T, []*bool]) Stream[[]*bool] {
	return NewConcurrentStream(orderlyConcurrentDoStream(s, mapper), s.concurrency)
}

// MapToInt produces a new Stream[int] applying the
//provided Function[T, int] to the elements of the stream.
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
//
// It is a special case of Map() aiming to avoid the use of functions C or SC for native Go types.
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
func (s Stream[T]) MapToInt(mapper Function[T, int]) Stream[int] {
	return NewConcurrentStream(orderlyConcurrentDo(s, mapper), s.concurrency)
}

// FlatMapToInt produces a new Stream[int] applying the
// provided StreamFunction[T, int] to flatten the elements of the stream.
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
//
// It is a special case of FlatMap() aiming to avoid the use of functions C or SC for native Go types.
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
func (s Stream[T]) FlatMapToInt(mapper StreamFunction[T, int]) Stream[int] {
	return NewConcurrentStream(orderlyConcurrentDoStream(s, mapper), s.concurrency)
}

// MapToSInt produces a new Stream[[]int] applying the
//provided Function[T, []int] to the elements of the stream.
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
//
// It is a special case of Map() aiming to avoid the use of functions C or SC for native Go types.
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
func (s Stream[T]) MapToSInt(mapper Function[T, []int]) Stream[[]int] {
	return NewConcurrentStream(orderlyConcurrentDo(s, mapper), s.concurrency)
}

// FlatMapToSInt produces a new Stream[[]int] applying the
// provided StreamFunction[T, []int] to flatten the elements of the stream.
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
//
// It is a special case of FlatMap() aiming to avoid the use of functions C or SC for native Go types.
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
func (s Stream[T]) FlatMapToSInt(mapper StreamFunction[T, []int]) Stream[[]int] {
	return NewConcurrentStream(orderlyConcurrentDoStream(s, mapper), s.concurrency)
}

// MapToIntPtr produces a new Stream[*int] applying the
//provided Function[T, *int] to the elements of the stream.
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
//
// It is a special case of Map() aiming to avoid the use of functions C or SC for native Go types.
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
func (s Stream[T]) MapToIntPtr(mapper Function[T, *int]) Stream[*int] {
	return NewConcurrentStream(orderlyConcurrentDo(s, mapper), s.concurrency)
}

// FlatMapToIntPtr produces a new Stream[*int] applying the
// provided StreamFunction[T, *int] to flatten the elements of the stream.
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
//
// It is a special case of FlatMap() aiming to avoid the use of functions C or SC for native Go types.
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
func (s Stream[T]) FlatMapToIntPtr(mapper StreamFunction[T, *int]) Stream[*int] {
	return NewConcurrentStream(orderlyConcurrentDoStream(s, mapper), s.concurrency)
}

// MapToSIntPtr produces a new Stream[[]*int] applying the
//provided Function[T, []*int] to the elements of the stream.
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
//
// It is a special case of Map() aiming to avoid the use of functions C or SC for native Go types.
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
func (s Stream[T]) MapToSIntPtr(mapper Function[T, []*int]) Stream[[]*int] {
	return NewConcurrentStream(orderlyConcurrentDo(s, mapper), s.concurrency)
}

// FlatMapToSIntPtr produces a new Stream[[]*int] applying the
// provided StreamFunction[T, []*int] to flatten the elements of the stream.
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
//
// It is a special case of FlatMap() aiming to avoid the use of functions C or SC for native Go types.
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
func (s Stream[T]) FlatMapToSIntPtr(mapper StreamFunction[T, []*int]) Stream[[]*int] {
	return NewConcurrentStream(orderlyConcurrentDoStream(s, mapper), s.concurrency)
}

// MapToInt8 produces a new Stream[int8] applying the
//provided Function[T, int8] to the elements of the stream.
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
//
// It is a special case of Map() aiming to avoid the use of functions C or SC for native Go types.
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
func (s Stream[T]) MapToInt8(mapper Function[T, int8]) Stream[int8] {
	return NewConcurrentStream(orderlyConcurrentDo(s, mapper), s.concurrency)
}

// FlatMapToInt8 produces a new Stream[int8] applying the
// provided StreamFunction[T, int8] to flatten the elements of the stream.
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
//
// It is a special case of FlatMap() aiming to avoid the use of functions C or SC for native Go types.
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
func (s Stream[T]) FlatMapToInt8(mapper StreamFunction[T, int8]) Stream[int8] {
	return NewConcurrentStream(orderlyConcurrentDoStream(s, mapper), s.concurrency)
}

// MapToSInt8 produces a new Stream[[]int8] applying the
//provided Function[T, []int8] to the elements of the stream.
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
//
// It is a special case of Map() aiming to avoid the use of functions C or SC for native Go types.
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
func (s Stream[T]) MapToSInt8(mapper Function[T, []int8]) Stream[[]int8] {
	return NewConcurrentStream(orderlyConcurrentDo(s, mapper), s.concurrency)
}

// FlatMapToSInt8 produces a new Stream[[]int8] applying the
// provided StreamFunction[T, []int8] to flatten the elements of the stream.
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
//
// It is a special case of FlatMap() aiming to avoid the use of functions C or SC for native Go types.
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
func (s Stream[T]) FlatMapToSInt8(mapper StreamFunction[T, []int8]) Stream[[]int8] {
	return NewConcurrentStream(orderlyConcurrentDoStream(s, mapper), s.concurrency)
}

// MapToInt8Ptr produces a new Stream[*int8] applying the
//provided Function[T, *int8] to the elements of the stream.
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
//
// It is a special case of Map() aiming to avoid the use of functions C or SC for native Go types.
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
func (s Stream[T]) MapToInt8Ptr(mapper Function[T, *int8]) Stream[*int8] {
	return NewConcurrentStream(orderlyConcurrentDo(s, mapper), s.concurrency)
}

// FlatMapToInt8Ptr produces a new Stream[*int8] applying the
// provided StreamFunction[T, *int8] to flatten the elements of the stream.
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
//
// It is a special case of FlatMap() aiming to avoid the use of functions C or SC for native Go types.
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
func (s Stream[T]) FlatMapToInt8Ptr(mapper StreamFunction[T, *int8]) Stream[*int8] {
	return NewConcurrentStream(orderlyConcurrentDoStream(s, mapper), s.concurrency)
}

// MapToSInt8Ptr produces a new Stream[[]*int8] applying the
//provided Function[T, []*int8] to the elements of the stream.
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
//
// It is a special case of Map() aiming to avoid the use of functions C or SC for native Go types.
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
func (s Stream[T]) MapToSInt8Ptr(mapper Function[T, []*int8]) Stream[[]*int8] {
	return NewConcurrentStream(orderlyConcurrentDo(s, mapper), s.concurrency)
}

// FlatMapToSInt8Ptr produces a new Stream[[]*int8] applying the
// provided StreamFunction[T, []*int8] to flatten the elements of the stream.
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
//
// It is a special case of FlatMap() aiming to avoid the use of functions C or SC for native Go types.
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
func (s Stream[T]) FlatMapToSInt8Ptr(mapper StreamFunction[T, []*int8]) Stream[[]*int8] {
	return NewConcurrentStream(orderlyConcurrentDoStream(s, mapper), s.concurrency)
}

// MapToInt16 produces a new Stream[int16] applying the
//provided Function[T, int16] to the elements of the stream.
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
//
// It is a special case of Map() aiming to avoid the use of functions C or SC for native Go types.
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
func (s Stream[T]) MapToInt16(mapper Function[T, int16]) Stream[int16] {
	return NewConcurrentStream(orderlyConcurrentDo(s, mapper), s.concurrency)
}

// FlatMapToInt16 produces a new Stream[int16] applying the
// provided StreamFunction[T, int16] to flatten the elements of the stream.
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
//
// It is a special case of FlatMap() aiming to avoid the use of functions C or SC for native Go types.
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
func (s Stream[T]) FlatMapToInt16(mapper StreamFunction[T, int16]) Stream[int16] {
	return NewConcurrentStream(orderlyConcurrentDoStream(s, mapper), s.concurrency)
}

// MapToSInt16 produces a new Stream[[]int16] applying the
//provided Function[T, []int16] to the elements of the stream.
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
//
// It is a special case of Map() aiming to avoid the use of functions C or SC for native Go types.
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
func (s Stream[T]) MapToSInt16(mapper Function[T, []int16]) Stream[[]int16] {
	return NewConcurrentStream(orderlyConcurrentDo(s, mapper), s.concurrency)
}

// FlatMapToSInt16 produces a new Stream[[]int16] applying the
// provided StreamFunction[T, []int16] to flatten the elements of the stream.
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
//
// It is a special case of FlatMap() aiming to avoid the use of functions C or SC for native Go types.
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
func (s Stream[T]) FlatMapToSInt16(mapper StreamFunction[T, []int16]) Stream[[]int16] {
	return NewConcurrentStream(orderlyConcurrentDoStream(s, mapper), s.concurrency)
}

// MapToInt16Ptr produces a new Stream[*int16] applying the
//provided Function[T, *int16] to the elements of the stream.
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
//
// It is a special case of Map() aiming to avoid the use of functions C or SC for native Go types.
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
func (s Stream[T]) MapToInt16Ptr(mapper Function[T, *int16]) Stream[*int16] {
	return NewConcurrentStream(orderlyConcurrentDo(s, mapper), s.concurrency)
}

// FlatMapToInt16Ptr produces a new Stream[*int16] applying the
// provided StreamFunction[T, *int16] to flatten the elements of the stream.
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
//
// It is a special case of FlatMap() aiming to avoid the use of functions C or SC for native Go types.
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
func (s Stream[T]) FlatMapToInt16Ptr(mapper StreamFunction[T, *int16]) Stream[*int16] {
	return NewConcurrentStream(orderlyConcurrentDoStream(s, mapper), s.concurrency)
}

// MapToSInt16Ptr produces a new Stream[[]*int16] applying the
//provided Function[T, []*int16] to the elements of the stream.
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
//
// It is a special case of Map() aiming to avoid the use of functions C or SC for native Go types.
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
func (s Stream[T]) MapToSInt16Ptr(mapper Function[T, []*int16]) Stream[[]*int16] {
	return NewConcurrentStream(orderlyConcurrentDo(s, mapper), s.concurrency)
}

// FlatMapToSInt16Ptr produces a new Stream[[]*int16] applying the
// provided StreamFunction[T, []*int16] to flatten the elements of the stream.
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
//
// It is a special case of FlatMap() aiming to avoid the use of functions C or SC for native Go types.
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
func (s Stream[T]) FlatMapToSInt16Ptr(mapper StreamFunction[T, []*int16]) Stream[[]*int16] {
	return NewConcurrentStream(orderlyConcurrentDoStream(s, mapper), s.concurrency)
}

// MapToInt32 produces a new Stream[int32] applying the
//provided Function[T, int32] to the elements of the stream.
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
//
// It is a special case of Map() aiming to avoid the use of functions C or SC for native Go types.
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
func (s Stream[T]) MapToInt32(mapper Function[T, int32]) Stream[int32] {
	return NewConcurrentStream(orderlyConcurrentDo(s, mapper), s.concurrency)
}

// FlatMapToInt32 produces a new Stream[int32] applying the
// provided StreamFunction[T, int32] to flatten the elements of the stream.
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
//
// It is a special case of FlatMap() aiming to avoid the use of functions C or SC for native Go types.
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
func (s Stream[T]) FlatMapToInt32(mapper StreamFunction[T, int32]) Stream[int32] {
	return NewConcurrentStream(orderlyConcurrentDoStream(s, mapper), s.concurrency)
}

// MapToSInt32 produces a new Stream[[]int32] applying the
//provided Function[T, []int32] to the elements of the stream.
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
//
// It is a special case of Map() aiming to avoid the use of functions C or SC for native Go types.
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
func (s Stream[T]) MapToSInt32(mapper Function[T, []int32]) Stream[[]int32] {
	return NewConcurrentStream(orderlyConcurrentDo(s, mapper), s.concurrency)
}

// FlatMapToSInt32 produces a new Stream[[]int32] applying the
// provided StreamFunction[T, []int32] to flatten the elements of the stream.
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
//
// It is a special case of FlatMap() aiming to avoid the use of functions C or SC for native Go types.
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
func (s Stream[T]) FlatMapToSInt32(mapper StreamFunction[T, []int32]) Stream[[]int32] {
	return NewConcurrentStream(orderlyConcurrentDoStream(s, mapper), s.concurrency)
}

// MapToInt32Ptr produces a new Stream[*int32] applying the
//provided Function[T, *int32] to the elements of the stream.
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
//
// It is a special case of Map() aiming to avoid the use of functions C or SC for native Go types.
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
func (s Stream[T]) MapToInt32Ptr(mapper Function[T, *int32]) Stream[*int32] {
	return NewConcurrentStream(orderlyConcurrentDo(s, mapper), s.concurrency)
}

// FlatMapToInt32Ptr produces a new Stream[*int32] applying the
// provided StreamFunction[T, *int32] to flatten the elements of the stream.
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
//
// It is a special case of FlatMap() aiming to avoid the use of functions C or SC for native Go types.
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
func (s Stream[T]) FlatMapToInt32Ptr(mapper StreamFunction[T, *int32]) Stream[*int32] {
	return NewConcurrentStream(orderlyConcurrentDoStream(s, mapper), s.concurrency)
}

// MapToSInt32Ptr produces a new Stream[[]*int32] applying the
//provided Function[T, []*int32] to the elements of the stream.
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
//
// It is a special case of Map() aiming to avoid the use of functions C or SC for native Go types.
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
func (s Stream[T]) MapToSInt32Ptr(mapper Function[T, []*int32]) Stream[[]*int32] {
	return NewConcurrentStream(orderlyConcurrentDo(s, mapper), s.concurrency)
}

// FlatMapToSInt32Ptr produces a new Stream[[]*int32] applying the
// provided StreamFunction[T, []*int32] to flatten the elements of the stream.
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
//
// It is a special case of FlatMap() aiming to avoid the use of functions C or SC for native Go types.
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
func (s Stream[T]) FlatMapToSInt32Ptr(mapper StreamFunction[T, []*int32]) Stream[[]*int32] {
	return NewConcurrentStream(orderlyConcurrentDoStream(s, mapper), s.concurrency)
}

// MapToInt64 produces a new Stream[int64] applying the
//provided Function[T, int64] to the elements of the stream.
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
//
// It is a special case of Map() aiming to avoid the use of functions C or SC for native Go types.
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
func (s Stream[T]) MapToInt64(mapper Function[T, int64]) Stream[int64] {
	return NewConcurrentStream(orderlyConcurrentDo(s, mapper), s.concurrency)
}

// FlatMapToInt64 produces a new Stream[int64] applying the
// provided StreamFunction[T, int64] to flatten the elements of the stream.
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
//
// It is a special case of FlatMap() aiming to avoid the use of functions C or SC for native Go types.
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
func (s Stream[T]) FlatMapToInt64(mapper StreamFunction[T, int64]) Stream[int64] {
	return NewConcurrentStream(orderlyConcurrentDoStream(s, mapper), s.concurrency)
}

// MapToSInt64 produces a new Stream[[]int64] applying the
//provided Function[T, []int64] to the elements of the stream.
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
//
// It is a special case of Map() aiming to avoid the use of functions C or SC for native Go types.
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
func (s Stream[T]) MapToSInt64(mapper Function[T, []int64]) Stream[[]int64] {
	return NewConcurrentStream(orderlyConcurrentDo(s, mapper), s.concurrency)
}

// FlatMapToSInt64 produces a new Stream[[]int64] applying the
// provided StreamFunction[T, []int64] to flatten the elements of the stream.
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
//
// It is a special case of FlatMap() aiming to avoid the use of functions C or SC for native Go types.
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
func (s Stream[T]) FlatMapToSInt64(mapper StreamFunction[T, []int64]) Stream[[]int64] {
	return NewConcurrentStream(orderlyConcurrentDoStream(s, mapper), s.concurrency)
}

// MapToInt64Ptr produces a new Stream[*int64] applying the
//provided Function[T, *int64] to the elements of the stream.
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
//
// It is a special case of Map() aiming to avoid the use of functions C or SC for native Go types.
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
func (s Stream[T]) MapToInt64Ptr(mapper Function[T, *int64]) Stream[*int64] {
	return NewConcurrentStream(orderlyConcurrentDo(s, mapper), s.concurrency)
}

// FlatMapToInt64Ptr produces a new Stream[*int64] applying the
// provided StreamFunction[T, *int64] to flatten the elements of the stream.
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
//
// It is a special case of FlatMap() aiming to avoid the use of functions C or SC for native Go types.
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
func (s Stream[T]) FlatMapToInt64Ptr(mapper StreamFunction[T, *int64]) Stream[*int64] {
	return NewConcurrentStream(orderlyConcurrentDoStream(s, mapper), s.concurrency)
}

// MapToSInt64Ptr produces a new Stream[[]*int64] applying the
//provided Function[T, []*int64] to the elements of the stream.
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
//
// It is a special case of Map() aiming to avoid the use of functions C or SC for native Go types.
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
func (s Stream[T]) MapToSInt64Ptr(mapper Function[T, []*int64]) Stream[[]*int64] {
	return NewConcurrentStream(orderlyConcurrentDo(s, mapper), s.concurrency)
}

// FlatMapToSInt64Ptr produces a new Stream[[]*int64] applying the
// provided StreamFunction[T, []*int64] to flatten the elements of the stream.
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
//
// It is a special case of FlatMap() aiming to avoid the use of functions C or SC for native Go types.
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
func (s Stream[T]) FlatMapToSInt64Ptr(mapper StreamFunction[T, []*int64]) Stream[[]*int64] {
	return NewConcurrentStream(orderlyConcurrentDoStream(s, mapper), s.concurrency)
}

// MapToUint produces a new Stream[uint] applying the
//provided Function[T, uint] to the elements of the stream.
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
//
// It is a special case of Map() aiming to avoid the use of functions C or SC for native Go types.
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
func (s Stream[T]) MapToUint(mapper Function[T, uint]) Stream[uint] {
	return NewConcurrentStream(orderlyConcurrentDo(s, mapper), s.concurrency)
}

// FlatMapToUint produces a new Stream[uint] applying the
// provided StreamFunction[T, uint] to flatten the elements of the stream.
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
//
// It is a special case of FlatMap() aiming to avoid the use of functions C or SC for native Go types.
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
func (s Stream[T]) FlatMapToUint(mapper StreamFunction[T, uint]) Stream[uint] {
	return NewConcurrentStream(orderlyConcurrentDoStream(s, mapper), s.concurrency)
}

// MapToSUint produces a new Stream[[]uint] applying the
//provided Function[T, []uint] to the elements of the stream.
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
//
// It is a special case of Map() aiming to avoid the use of functions C or SC for native Go types.
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
func (s Stream[T]) MapToSUint(mapper Function[T, []uint]) Stream[[]uint] {
	return NewConcurrentStream(orderlyConcurrentDo(s, mapper), s.concurrency)
}

// FlatMapToSUint produces a new Stream[[]uint] applying the
// provided StreamFunction[T, []uint] to flatten the elements of the stream.
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
//
// It is a special case of FlatMap() aiming to avoid the use of functions C or SC for native Go types.
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
func (s Stream[T]) FlatMapToSUint(mapper StreamFunction[T, []uint]) Stream[[]uint] {
	return NewConcurrentStream(orderlyConcurrentDoStream(s, mapper), s.concurrency)
}

// MapToUintPtr produces a new Stream[*uint] applying the
//provided Function[T, *uint] to the elements of the stream.
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
//
// It is a special case of Map() aiming to avoid the use of functions C or SC for native Go types.
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
func (s Stream[T]) MapToUintPtr(mapper Function[T, *uint]) Stream[*uint] {
	return NewConcurrentStream(orderlyConcurrentDo(s, mapper), s.concurrency)
}

// FlatMapToUintPtr produces a new Stream[*uint] applying the
// provided StreamFunction[T, *uint] to flatten the elements of the stream.
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
//
// It is a special case of FlatMap() aiming to avoid the use of functions C or SC for native Go types.
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
func (s Stream[T]) FlatMapToUintPtr(mapper StreamFunction[T, *uint]) Stream[*uint] {
	return NewConcurrentStream(orderlyConcurrentDoStream(s, mapper), s.concurrency)
}

// MapToSUintPtr produces a new Stream[[]*uint] applying the
//provided Function[T, []*uint] to the elements of the stream.
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
//
// It is a special case of Map() aiming to avoid the use of functions C or SC for native Go types.
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
func (s Stream[T]) MapToSUintPtr(mapper Function[T, []*uint]) Stream[[]*uint] {
	return NewConcurrentStream(orderlyConcurrentDo(s, mapper), s.concurrency)
}

// FlatMapToSUintPtr produces a new Stream[[]*uint] applying the
// provided StreamFunction[T, []*uint] to flatten the elements of the stream.
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
//
// It is a special case of FlatMap() aiming to avoid the use of functions C or SC for native Go types.
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
func (s Stream[T]) FlatMapToSUintPtr(mapper StreamFunction[T, []*uint]) Stream[[]*uint] {
	return NewConcurrentStream(orderlyConcurrentDoStream(s, mapper), s.concurrency)
}

// MapToUint8 produces a new Stream[uint8] applying the
//provided Function[T, uint8] to the elements of the stream.
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
//
// It is a special case of Map() aiming to avoid the use of functions C or SC for native Go types.
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
func (s Stream[T]) MapToUint8(mapper Function[T, uint8]) Stream[uint8] {
	return NewConcurrentStream(orderlyConcurrentDo(s, mapper), s.concurrency)
}

// FlatMapToUint8 produces a new Stream[uint8] applying the
// provided StreamFunction[T, uint8] to flatten the elements of the stream.
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
//
// It is a special case of FlatMap() aiming to avoid the use of functions C or SC for native Go types.
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
func (s Stream[T]) FlatMapToUint8(mapper StreamFunction[T, uint8]) Stream[uint8] {
	return NewConcurrentStream(orderlyConcurrentDoStream(s, mapper), s.concurrency)
}

// MapToSUint8 produces a new Stream[[]uint8] applying the
//provided Function[T, []uint8] to the elements of the stream.
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
//
// It is a special case of Map() aiming to avoid the use of functions C or SC for native Go types.
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
func (s Stream[T]) MapToSUint8(mapper Function[T, []uint8]) Stream[[]uint8] {
	return NewConcurrentStream(orderlyConcurrentDo(s, mapper), s.concurrency)
}

// FlatMapToSUint8 produces a new Stream[[]uint8] applying the
// provided StreamFunction[T, []uint8] to flatten the elements of the stream.
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
//
// It is a special case of FlatMap() aiming to avoid the use of functions C or SC for native Go types.
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
func (s Stream[T]) FlatMapToSUint8(mapper StreamFunction[T, []uint8]) Stream[[]uint8] {
	return NewConcurrentStream(orderlyConcurrentDoStream(s, mapper), s.concurrency)
}

// MapToUint8Ptr produces a new Stream[*uint8] applying the
//provided Function[T, *uint8] to the elements of the stream.
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
//
// It is a special case of Map() aiming to avoid the use of functions C or SC for native Go types.
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
func (s Stream[T]) MapToUint8Ptr(mapper Function[T, *uint8]) Stream[*uint8] {
	return NewConcurrentStream(orderlyConcurrentDo(s, mapper), s.concurrency)
}

// FlatMapToUint8Ptr produces a new Stream[*uint8] applying the
// provided StreamFunction[T, *uint8] to flatten the elements of the stream.
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
//
// It is a special case of FlatMap() aiming to avoid the use of functions C or SC for native Go types.
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
func (s Stream[T]) FlatMapToUint8Ptr(mapper StreamFunction[T, *uint8]) Stream[*uint8] {
	return NewConcurrentStream(orderlyConcurrentDoStream(s, mapper), s.concurrency)
}

// MapToSUint8Ptr produces a new Stream[[]*uint8] applying the
//provided Function[T, []*uint8] to the elements of the stream.
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
//
// It is a special case of Map() aiming to avoid the use of functions C or SC for native Go types.
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
func (s Stream[T]) MapToSUint8Ptr(mapper Function[T, []*uint8]) Stream[[]*uint8] {
	return NewConcurrentStream(orderlyConcurrentDo(s, mapper), s.concurrency)
}

// FlatMapToSUint8Ptr produces a new Stream[[]*uint8] applying the
// provided StreamFunction[T, []*uint8] to flatten the elements of the stream.
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
//
// It is a special case of FlatMap() aiming to avoid the use of functions C or SC for native Go types.
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
func (s Stream[T]) FlatMapToSUint8Ptr(mapper StreamFunction[T, []*uint8]) Stream[[]*uint8] {
	return NewConcurrentStream(orderlyConcurrentDoStream(s, mapper), s.concurrency)
}

// MapToUint16 produces a new Stream[uint16] applying the
//provided Function[T, uint16] to the elements of the stream.
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
//
// It is a special case of Map() aiming to avoid the use of functions C or SC for native Go types.
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
func (s Stream[T]) MapToUint16(mapper Function[T, uint16]) Stream[uint16] {
	return NewConcurrentStream(orderlyConcurrentDo(s, mapper), s.concurrency)
}

// FlatMapToUint16 produces a new Stream[uint16] applying the
// provided StreamFunction[T, uint16] to flatten the elements of the stream.
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
//
// It is a special case of FlatMap() aiming to avoid the use of functions C or SC for native Go types.
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
func (s Stream[T]) FlatMapToUint16(mapper StreamFunction[T, uint16]) Stream[uint16] {
	return NewConcurrentStream(orderlyConcurrentDoStream(s, mapper), s.concurrency)
}

// MapToSUint16 produces a new Stream[[]uint16] applying the
//provided Function[T, []uint16] to the elements of the stream.
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
//
// It is a special case of Map() aiming to avoid the use of functions C or SC for native Go types.
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
func (s Stream[T]) MapToSUint16(mapper Function[T, []uint16]) Stream[[]uint16] {
	return NewConcurrentStream(orderlyConcurrentDo(s, mapper), s.concurrency)
}

// FlatMapToSUint16 produces a new Stream[[]uint16] applying the
// provided StreamFunction[T, []uint16] to flatten the elements of the stream.
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
//
// It is a special case of FlatMap() aiming to avoid the use of functions C or SC for native Go types.
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
func (s Stream[T]) FlatMapToSUint16(mapper StreamFunction[T, []uint16]) Stream[[]uint16] {
	return NewConcurrentStream(orderlyConcurrentDoStream(s, mapper), s.concurrency)
}

// MapToUint16Ptr produces a new Stream[*uint16] applying the
//provided Function[T, *uint16] to the elements of the stream.
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
//
// It is a special case of Map() aiming to avoid the use of functions C or SC for native Go types.
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
func (s Stream[T]) MapToUint16Ptr(mapper Function[T, *uint16]) Stream[*uint16] {
	return NewConcurrentStream(orderlyConcurrentDo(s, mapper), s.concurrency)
}

// FlatMapToUint16Ptr produces a new Stream[*uint16] applying the
// provided StreamFunction[T, *uint16] to flatten the elements of the stream.
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
//
// It is a special case of FlatMap() aiming to avoid the use of functions C or SC for native Go types.
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
func (s Stream[T]) FlatMapToUint16Ptr(mapper StreamFunction[T, *uint16]) Stream[*uint16] {
	return NewConcurrentStream(orderlyConcurrentDoStream(s, mapper), s.concurrency)
}

// MapToSUint16Ptr produces a new Stream[[]*uint16] applying the
//provided Function[T, []*uint16] to the elements of the stream.
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
//
// It is a special case of Map() aiming to avoid the use of functions C or SC for native Go types.
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
func (s Stream[T]) MapToSUint16Ptr(mapper Function[T, []*uint16]) Stream[[]*uint16] {
	return NewConcurrentStream(orderlyConcurrentDo(s, mapper), s.concurrency)
}

// FlatMapToSUint16Ptr produces a new Stream[[]*uint16] applying the
// provided StreamFunction[T, []*uint16] to flatten the elements of the stream.
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
//
// It is a special case of FlatMap() aiming to avoid the use of functions C or SC for native Go types.
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
func (s Stream[T]) FlatMapToSUint16Ptr(mapper StreamFunction[T, []*uint16]) Stream[[]*uint16] {
	return NewConcurrentStream(orderlyConcurrentDoStream(s, mapper), s.concurrency)
}

// MapToUint32 produces a new Stream[uint32] applying the
//provided Function[T, uint32] to the elements of the stream.
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
//
// It is a special case of Map() aiming to avoid the use of functions C or SC for native Go types.
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
func (s Stream[T]) MapToUint32(mapper Function[T, uint32]) Stream[uint32] {
	return NewConcurrentStream(orderlyConcurrentDo(s, mapper), s.concurrency)
}

// FlatMapToUint32 produces a new Stream[uint32] applying the
// provided StreamFunction[T, uint32] to flatten the elements of the stream.
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
//
// It is a special case of FlatMap() aiming to avoid the use of functions C or SC for native Go types.
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
func (s Stream[T]) FlatMapToUint32(mapper StreamFunction[T, uint32]) Stream[uint32] {
	return NewConcurrentStream(orderlyConcurrentDoStream(s, mapper), s.concurrency)
}

// MapToSUint32 produces a new Stream[[]uint32] applying the
//provided Function[T, []uint32] to the elements of the stream.
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
//
// It is a special case of Map() aiming to avoid the use of functions C or SC for native Go types.
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
func (s Stream[T]) MapToSUint32(mapper Function[T, []uint32]) Stream[[]uint32] {
	return NewConcurrentStream(orderlyConcurrentDo(s, mapper), s.concurrency)
}

// FlatMapToSUint32 produces a new Stream[[]uint32] applying the
// provided StreamFunction[T, []uint32] to flatten the elements of the stream.
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
//
// It is a special case of FlatMap() aiming to avoid the use of functions C or SC for native Go types.
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
func (s Stream[T]) FlatMapToSUint32(mapper StreamFunction[T, []uint32]) Stream[[]uint32] {
	return NewConcurrentStream(orderlyConcurrentDoStream(s, mapper), s.concurrency)
}

// MapToUint32Ptr produces a new Stream[*uint32] applying the
//provided Function[T, *uint32] to the elements of the stream.
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
//
// It is a special case of Map() aiming to avoid the use of functions C or SC for native Go types.
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
func (s Stream[T]) MapToUint32Ptr(mapper Function[T, *uint32]) Stream[*uint32] {
	return NewConcurrentStream(orderlyConcurrentDo(s, mapper), s.concurrency)
}

// FlatMapToUint32Ptr produces a new Stream[*uint32] applying the
// provided StreamFunction[T, *uint32] to flatten the elements of the stream.
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
//
// It is a special case of FlatMap() aiming to avoid the use of functions C or SC for native Go types.
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
func (s Stream[T]) FlatMapToUint32Ptr(mapper StreamFunction[T, *uint32]) Stream[*uint32] {
	return NewConcurrentStream(orderlyConcurrentDoStream(s, mapper), s.concurrency)
}

// MapToSUint32Ptr produces a new Stream[[]*uint32] applying the
//provided Function[T, []*uint32] to the elements of the stream.
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
//
// It is a special case of Map() aiming to avoid the use of functions C or SC for native Go types.
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
func (s Stream[T]) MapToSUint32Ptr(mapper Function[T, []*uint32]) Stream[[]*uint32] {
	return NewConcurrentStream(orderlyConcurrentDo(s, mapper), s.concurrency)
}

// FlatMapToSUint32Ptr produces a new Stream[[]*uint32] applying the
// provided StreamFunction[T, []*uint32] to flatten the elements of the stream.
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
//
// It is a special case of FlatMap() aiming to avoid the use of functions C or SC for native Go types.
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
func (s Stream[T]) FlatMapToSUint32Ptr(mapper StreamFunction[T, []*uint32]) Stream[[]*uint32] {
	return NewConcurrentStream(orderlyConcurrentDoStream(s, mapper), s.concurrency)
}

// MapToUint64 produces a new Stream[uint64] applying the
//provided Function[T, uint64] to the elements of the stream.
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
//
// It is a special case of Map() aiming to avoid the use of functions C or SC for native Go types.
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
func (s Stream[T]) MapToUint64(mapper Function[T, uint64]) Stream[uint64] {
	return NewConcurrentStream(orderlyConcurrentDo(s, mapper), s.concurrency)
}

// FlatMapToUint64 produces a new Stream[uint64] applying the
// provided StreamFunction[T, uint64] to flatten the elements of the stream.
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
//
// It is a special case of FlatMap() aiming to avoid the use of functions C or SC for native Go types.
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
func (s Stream[T]) FlatMapToUint64(mapper StreamFunction[T, uint64]) Stream[uint64] {
	return NewConcurrentStream(orderlyConcurrentDoStream(s, mapper), s.concurrency)
}

// MapToSUint64 produces a new Stream[[]uint64] applying the
//provided Function[T, []uint64] to the elements of the stream.
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
//
// It is a special case of Map() aiming to avoid the use of functions C or SC for native Go types.
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
func (s Stream[T]) MapToSUint64(mapper Function[T, []uint64]) Stream[[]uint64] {
	return NewConcurrentStream(orderlyConcurrentDo(s, mapper), s.concurrency)
}

// FlatMapToSUint64 produces a new Stream[[]uint64] applying the
// provided StreamFunction[T, []uint64] to flatten the elements of the stream.
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
//
// It is a special case of FlatMap() aiming to avoid the use of functions C or SC for native Go types.
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
func (s Stream[T]) FlatMapToSUint64(mapper StreamFunction[T, []uint64]) Stream[[]uint64] {
	return NewConcurrentStream(orderlyConcurrentDoStream(s, mapper), s.concurrency)
}

// MapToUint64Ptr produces a new Stream[*uint64] applying the
//provided Function[T, *uint64] to the elements of the stream.
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
//
// It is a special case of Map() aiming to avoid the use of functions C or SC for native Go types.
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
func (s Stream[T]) MapToUint64Ptr(mapper Function[T, *uint64]) Stream[*uint64] {
	return NewConcurrentStream(orderlyConcurrentDo(s, mapper), s.concurrency)
}

// FlatMapToUint64Ptr produces a new Stream[*uint64] applying the
// provided StreamFunction[T, *uint64] to flatten the elements of the stream.
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
//
// It is a special case of FlatMap() aiming to avoid the use of functions C or SC for native Go types.
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
func (s Stream[T]) FlatMapToUint64Ptr(mapper StreamFunction[T, *uint64]) Stream[*uint64] {
	return NewConcurrentStream(orderlyConcurrentDoStream(s, mapper), s.concurrency)
}

// MapToSUint64Ptr produces a new Stream[[]*uint64] applying the
//provided Function[T, []*uint64] to the elements of the stream.
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
//
// It is a special case of Map() aiming to avoid the use of functions C or SC for native Go types.
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
func (s Stream[T]) MapToSUint64Ptr(mapper Function[T, []*uint64]) Stream[[]*uint64] {
	return NewConcurrentStream(orderlyConcurrentDo(s, mapper), s.concurrency)
}

// FlatMapToSUint64Ptr produces a new Stream[[]*uint64] applying the
// provided StreamFunction[T, []*uint64] to flatten the elements of the stream.
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
//
// It is a special case of FlatMap() aiming to avoid the use of functions C or SC for native Go types.
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
func (s Stream[T]) FlatMapToSUint64Ptr(mapper StreamFunction[T, []*uint64]) Stream[[]*uint64] {
	return NewConcurrentStream(orderlyConcurrentDoStream(s, mapper), s.concurrency)
}

// MapToFloat32 produces a new Stream[float32] applying the
//provided Function[T, float32] to the elements of the stream.
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
//
// It is a special case of Map() aiming to avoid the use of functions C or SC for native Go types.
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
func (s Stream[T]) MapToFloat32(mapper Function[T, float32]) Stream[float32] {
	return NewConcurrentStream(orderlyConcurrentDo(s, mapper), s.concurrency)
}

// FlatMapToFloat32 produces a new Stream[float32] applying the
// provided StreamFunction[T, float32] to flatten the elements of the stream.
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
//
// It is a special case of FlatMap() aiming to avoid the use of functions C or SC for native Go types.
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
func (s Stream[T]) FlatMapToFloat32(mapper StreamFunction[T, float32]) Stream[float32] {
	return NewConcurrentStream(orderlyConcurrentDoStream(s, mapper), s.concurrency)
}

// MapToSFloat32 produces a new Stream[[]float32] applying the
//provided Function[T, []float32] to the elements of the stream.
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
//
// It is a special case of Map() aiming to avoid the use of functions C or SC for native Go types.
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
func (s Stream[T]) MapToSFloat32(mapper Function[T, []float32]) Stream[[]float32] {
	return NewConcurrentStream(orderlyConcurrentDo(s, mapper), s.concurrency)
}

// FlatMapToSFloat32 produces a new Stream[[]float32] applying the
// provided StreamFunction[T, []float32] to flatten the elements of the stream.
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
//
// It is a special case of FlatMap() aiming to avoid the use of functions C or SC for native Go types.
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
func (s Stream[T]) FlatMapToSFloat32(mapper StreamFunction[T, []float32]) Stream[[]float32] {
	return NewConcurrentStream(orderlyConcurrentDoStream(s, mapper), s.concurrency)
}

// MapToFloat32Ptr produces a new Stream[*float32] applying the
//provided Function[T, *float32] to the elements of the stream.
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
//
// It is a special case of Map() aiming to avoid the use of functions C or SC for native Go types.
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
func (s Stream[T]) MapToFloat32Ptr(mapper Function[T, *float32]) Stream[*float32] {
	return NewConcurrentStream(orderlyConcurrentDo(s, mapper), s.concurrency)
}

// FlatMapToFloat32Ptr produces a new Stream[*float32] applying the
// provided StreamFunction[T, *float32] to flatten the elements of the stream.
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
//
// It is a special case of FlatMap() aiming to avoid the use of functions C or SC for native Go types.
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
func (s Stream[T]) FlatMapToFloat32Ptr(mapper StreamFunction[T, *float32]) Stream[*float32] {
	return NewConcurrentStream(orderlyConcurrentDoStream(s, mapper), s.concurrency)
}

// MapToSFloat32Ptr produces a new Stream[[]*float32] applying the
//provided Function[T, []*float32] to the elements of the stream.
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
//
// It is a special case of Map() aiming to avoid the use of functions C or SC for native Go types.
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
func (s Stream[T]) MapToSFloat32Ptr(mapper Function[T, []*float32]) Stream[[]*float32] {
	return NewConcurrentStream(orderlyConcurrentDo(s, mapper), s.concurrency)
}

// FlatMapToSFloat32Ptr produces a new Stream[[]*float32] applying the
// provided StreamFunction[T, []*float32] to flatten the elements of the stream.
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
//
// It is a special case of FlatMap() aiming to avoid the use of functions C or SC for native Go types.
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
func (s Stream[T]) FlatMapToSFloat32Ptr(mapper StreamFunction[T, []*float32]) Stream[[]*float32] {
	return NewConcurrentStream(orderlyConcurrentDoStream(s, mapper), s.concurrency)
}

// MapToFloat64 produces a new Stream[float64] applying the
//provided Function[T, float64] to the elements of the stream.
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
//
// It is a special case of Map() aiming to avoid the use of functions C or SC for native Go types.
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
func (s Stream[T]) MapToFloat64(mapper Function[T, float64]) Stream[float64] {
	return NewConcurrentStream(orderlyConcurrentDo(s, mapper), s.concurrency)
}

// FlatMapToFloat64 produces a new Stream[float64] applying the
// provided StreamFunction[T, float64] to flatten the elements of the stream.
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
//
// It is a special case of FlatMap() aiming to avoid the use of functions C or SC for native Go types.
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
func (s Stream[T]) FlatMapToFloat64(mapper StreamFunction[T, float64]) Stream[float64] {
	return NewConcurrentStream(orderlyConcurrentDoStream(s, mapper), s.concurrency)
}

// MapToSFloat64 produces a new Stream[[]float64] applying the
//provided Function[T, []float64] to the elements of the stream.
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
//
// It is a special case of Map() aiming to avoid the use of functions C or SC for native Go types.
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
func (s Stream[T]) MapToSFloat64(mapper Function[T, []float64]) Stream[[]float64] {
	return NewConcurrentStream(orderlyConcurrentDo(s, mapper), s.concurrency)
}

// FlatMapToSFloat64 produces a new Stream[[]float64] applying the
// provided StreamFunction[T, []float64] to flatten the elements of the stream.
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
//
// It is a special case of FlatMap() aiming to avoid the use of functions C or SC for native Go types.
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
func (s Stream[T]) FlatMapToSFloat64(mapper StreamFunction[T, []float64]) Stream[[]float64] {
	return NewConcurrentStream(orderlyConcurrentDoStream(s, mapper), s.concurrency)
}

// MapToFloat64Ptr produces a new Stream[*float64] applying the
//provided Function[T, *float64] to the elements of the stream.
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
//
// It is a special case of Map() aiming to avoid the use of functions C or SC for native Go types.
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
func (s Stream[T]) MapToFloat64Ptr(mapper Function[T, *float64]) Stream[*float64] {
	return NewConcurrentStream(orderlyConcurrentDo(s, mapper), s.concurrency)
}

// FlatMapToFloat64Ptr produces a new Stream[*float64] applying the
// provided StreamFunction[T, *float64] to flatten the elements of the stream.
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
//
// It is a special case of FlatMap() aiming to avoid the use of functions C or SC for native Go types.
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
func (s Stream[T]) FlatMapToFloat64Ptr(mapper StreamFunction[T, *float64]) Stream[*float64] {
	return NewConcurrentStream(orderlyConcurrentDoStream(s, mapper), s.concurrency)
}

// MapToSFloat64Ptr produces a new Stream[[]*float64] applying the
//provided Function[T, []*float64] to the elements of the stream.
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
//
// It is a special case of Map() aiming to avoid the use of functions C or SC for native Go types.
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
func (s Stream[T]) MapToSFloat64Ptr(mapper Function[T, []*float64]) Stream[[]*float64] {
	return NewConcurrentStream(orderlyConcurrentDo(s, mapper), s.concurrency)
}

// FlatMapToSFloat64Ptr produces a new Stream[[]*float64] applying the
// provided StreamFunction[T, []*float64] to flatten the elements of the stream.
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
//
// It is a special case of FlatMap() aiming to avoid the use of functions C or SC for native Go types.
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
func (s Stream[T]) FlatMapToSFloat64Ptr(mapper StreamFunction[T, []*float64]) Stream[[]*float64] {
	return NewConcurrentStream(orderlyConcurrentDoStream(s, mapper), s.concurrency)
}

// MapToComplex64 produces a new Stream[complex128] applying the
//provided Function[T, complex128] to the elements of the stream.
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
//
// It is a special case of Map() aiming to avoid the use of functions C or SC for native Go types.
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
func (s Stream[T]) MapToComplex64(mapper Function[T, complex128]) Stream[complex128] {
	return NewConcurrentStream(orderlyConcurrentDo(s, mapper), s.concurrency)
}

// FlatMapToComplex64 produces a new Stream[complex128] applying the
// provided StreamFunction[T, complex128] to flatten the elements of the stream.
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
//
// It is a special case of FlatMap() aiming to avoid the use of functions C or SC for native Go types.
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
func (s Stream[T]) FlatMapToComplex64(mapper StreamFunction[T, complex128]) Stream[complex128] {
	return NewConcurrentStream(orderlyConcurrentDoStream(s, mapper), s.concurrency)
}

// MapToSComplex64 produces a new Stream[[]complex128] applying the
//provided Function[T, []complex128] to the elements of the stream.
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
//
// It is a special case of Map() aiming to avoid the use of functions C or SC for native Go types.
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
func (s Stream[T]) MapToSComplex64(mapper Function[T, []complex128]) Stream[[]complex128] {
	return NewConcurrentStream(orderlyConcurrentDo(s, mapper), s.concurrency)
}

// FlatMapToSComplex64 produces a new Stream[[]complex128] applying the
// provided StreamFunction[T, []complex128] to flatten the elements of the stream.
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
//
// It is a special case of FlatMap() aiming to avoid the use of functions C or SC for native Go types.
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
func (s Stream[T]) FlatMapToSComplex64(mapper StreamFunction[T, []complex128]) Stream[[]complex128] {
	return NewConcurrentStream(orderlyConcurrentDoStream(s, mapper), s.concurrency)
}

// MapToComplex64Ptr produces a new Stream[*complex128] applying the
//provided Function[T, *complex128] to the elements of the stream.
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
//
// It is a special case of Map() aiming to avoid the use of functions C or SC for native Go types.
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
func (s Stream[T]) MapToComplex64Ptr(mapper Function[T, *complex128]) Stream[*complex128] {
	return NewConcurrentStream(orderlyConcurrentDo(s, mapper), s.concurrency)
}

// FlatMapToComplex64Ptr produces a new Stream[*complex128] applying the
// provided StreamFunction[T, *complex128] to flatten the elements of the stream.
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
//
// It is a special case of FlatMap() aiming to avoid the use of functions C or SC for native Go types.
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
func (s Stream[T]) FlatMapToComplex64Ptr(mapper StreamFunction[T, *complex128]) Stream[*complex128] {
	return NewConcurrentStream(orderlyConcurrentDoStream(s, mapper), s.concurrency)
}

// MapToSComplex64Ptr produces a new Stream[[]*complex128] applying the
//provided Function[T, []*complex128] to the elements of the stream.
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
//
// It is a special case of Map() aiming to avoid the use of functions C or SC for native Go types.
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
func (s Stream[T]) MapToSComplex64Ptr(mapper Function[T, []*complex128]) Stream[[]*complex128] {
	return NewConcurrentStream(orderlyConcurrentDo(s, mapper), s.concurrency)
}

// FlatMapToSComplex64Ptr produces a new Stream[[]*complex128] applying the
// provided StreamFunction[T, []*complex128] to flatten the elements of the stream.
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
//
// It is a special case of FlatMap() aiming to avoid the use of functions C or SC for native Go types.
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
func (s Stream[T]) FlatMapToSComplex64Ptr(mapper StreamFunction[T, []*complex128]) Stream[[]*complex128] {
	return NewConcurrentStream(orderlyConcurrentDoStream(s, mapper), s.concurrency)
}

// MapToComplex128 produces a new Stream[complex128] applying the
//provided Function[T, complex128] to the elements of the stream.
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
//
// It is a special case of Map() aiming to avoid the use of functions C or SC for native Go types.
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
func (s Stream[T]) MapToComplex128(mapper Function[T, complex128]) Stream[complex128] {
	return NewConcurrentStream(orderlyConcurrentDo(s, mapper), s.concurrency)
}

// FlatMapToComplex128 produces a new Stream[complex128] applying the
// provided StreamFunction[T, complex128] to flatten the elements of the stream.
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
//
// It is a special case of FlatMap() aiming to avoid the use of functions C or SC for native Go types.
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
func (s Stream[T]) FlatMapToComplex128(mapper StreamFunction[T, complex128]) Stream[complex128] {
	return NewConcurrentStream(orderlyConcurrentDoStream(s, mapper), s.concurrency)
}

// MapToSComplex128 produces a new Stream[[]complex128] applying the
//provided Function[T, []complex128] to the elements of the stream.
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
//
// It is a special case of Map() aiming to avoid the use of functions C or SC for native Go types.
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
func (s Stream[T]) MapToSComplex128(mapper Function[T, []complex128]) Stream[[]complex128] {
	return NewConcurrentStream(orderlyConcurrentDo(s, mapper), s.concurrency)
}

// FlatMapToSComplex128 produces a new Stream[[]complex128] applying the
// provided StreamFunction[T, []complex128] to flatten the elements of the stream.
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
//
// It is a special case of FlatMap() aiming to avoid the use of functions C or SC for native Go types.
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
func (s Stream[T]) FlatMapToSComplex128(mapper StreamFunction[T, []complex128]) Stream[[]complex128] {
	return NewConcurrentStream(orderlyConcurrentDoStream(s, mapper), s.concurrency)
}

// MapToComplex128Ptr produces a new Stream[*complex128] applying the
//provided Function[T, *complex128] to the elements of the stream.
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
//
// It is a special case of Map() aiming to avoid the use of functions C or SC for native Go types.
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
func (s Stream[T]) MapToComplex128Ptr(mapper Function[T, *complex128]) Stream[*complex128] {
	return NewConcurrentStream(orderlyConcurrentDo(s, mapper), s.concurrency)
}

// FlatMapToComplex128Ptr produces a new Stream[*complex128] applying the
// provided StreamFunction[T, *complex128] to flatten the elements of the stream.
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
//
// It is a special case of FlatMap() aiming to avoid the use of functions C or SC for native Go types.
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
func (s Stream[T]) FlatMapToComplex128Ptr(mapper StreamFunction[T, *complex128]) Stream[*complex128] {
	return NewConcurrentStream(orderlyConcurrentDoStream(s, mapper), s.concurrency)
}

// MapToSComplex128Ptr produces a new Stream[[]*complex128] applying the
//provided Function[T, []*complex128] to the elements of the stream.
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
//
// It is a special case of Map() aiming to avoid the use of functions C or SC for native Go types.
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
func (s Stream[T]) MapToSComplex128Ptr(mapper Function[T, []*complex128]) Stream[[]*complex128] {
	return NewConcurrentStream(orderlyConcurrentDo(s, mapper), s.concurrency)
}

// FlatMapToSComplex128Ptr produces a new Stream[[]*complex128] applying the
// provided StreamFunction[T, []*complex128] to flatten the elements of the stream.
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
//
// It is a special case of FlatMap() aiming to avoid the use of functions C or SC for native Go types.
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
func (s Stream[T]) FlatMapToSComplex128Ptr(mapper StreamFunction[T, []*complex128]) Stream[[]*complex128] {
	return NewConcurrentStream(orderlyConcurrentDoStream(s, mapper), s.concurrency)
}

// MapToString produces a new Stream[string] applying the
//provided Function[T, string] to the elements of the stream.
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
//
// It is a special case of Map() aiming to avoid the use of functions C or SC for native Go types.
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
func (s Stream[T]) MapToString(mapper Function[T, string]) Stream[string] {
	return NewConcurrentStream(orderlyConcurrentDo(s, mapper), s.concurrency)
}

// FlatMapToString produces a new Stream[string] applying the
// provided StreamFunction[T, string] to flatten the elements of the stream.
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
//
// It is a special case of FlatMap() aiming to avoid the use of functions C or SC for native Go types.
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
func (s Stream[T]) FlatMapToString(mapper StreamFunction[T, string]) Stream[string] {
	return NewConcurrentStream(orderlyConcurrentDoStream(s, mapper), s.concurrency)
}

// MapToSString produces a new Stream[[]string] applying the
//provided Function[T, []string] to the elements of the stream.
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
//
// It is a special case of Map() aiming to avoid the use of functions C or SC for native Go types.
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
func (s Stream[T]) MapToSString(mapper Function[T, []string]) Stream[[]string] {
	return NewConcurrentStream(orderlyConcurrentDo(s, mapper), s.concurrency)
}

// FlatMapToSString produces a new Stream[[]string] applying the
// provided StreamFunction[T, []string] to flatten the elements of the stream.
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
//
// It is a special case of FlatMap() aiming to avoid the use of functions C or SC for native Go types.
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
func (s Stream[T]) FlatMapToSString(mapper StreamFunction[T, []string]) Stream[[]string] {
	return NewConcurrentStream(orderlyConcurrentDoStream(s, mapper), s.concurrency)
}

// MapToStringPtr produces a new Stream[*string] applying the
//provided Function[T, *string] to the elements of the stream.
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
//
// It is a special case of Map() aiming to avoid the use of functions C or SC for native Go types.
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
func (s Stream[T]) MapToStringPtr(mapper Function[T, *string]) Stream[*string] {
	return NewConcurrentStream(orderlyConcurrentDo(s, mapper), s.concurrency)
}

// FlatMapToStringPtr produces a new Stream[*string] applying the
// provided StreamFunction[T, *string] to flatten the elements of the stream.
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
//
// It is a special case of FlatMap() aiming to avoid the use of functions C or SC for native Go types.
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
func (s Stream[T]) FlatMapToStringPtr(mapper StreamFunction[T, *string]) Stream[*string] {
	return NewConcurrentStream(orderlyConcurrentDoStream(s, mapper), s.concurrency)
}

// MapToSStringPtr produces a new Stream[[]*string] applying the
//provided Function[T, []*string] to the elements of the stream.
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
//
// It is a special case of Map() aiming to avoid the use of functions C or SC for native Go types.
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
func (s Stream[T]) MapToSStringPtr(mapper Function[T, []*string]) Stream[[]*string] {
	return NewConcurrentStream(orderlyConcurrentDo(s, mapper), s.concurrency)
}

// FlatMapToSStringPtr produces a new Stream[[]*string] applying the
// provided StreamFunction[T, []*string] to flatten the elements of the stream.
//
// This function streams continuously until the in-stream is closed at
// which point the out-stream will be closed too.
//
// It is a special case of FlatMap() aiming to avoid the use of functions C or SC for native Go types.
// It is provided as a convenience since Go 1.18 does not support parameterised methods.
func (s Stream[T]) FlatMapToSStringPtr(mapper StreamFunction[T, []*string]) Stream[[]*string] {
	return NewConcurrentStream(orderlyConcurrentDoStream(s, mapper), s.concurrency)
}

